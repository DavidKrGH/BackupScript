#!/bin/bash
# BackupScripts version 2.0.0
#################################### License ################################
# MIT License Copyright (c) 2023 David Krumm                                #
# All rights reserved.                                                      #
#                                                                           #
# This source code is licensed under the MIT license found in the           #
# LICENSE file in the root directory of this source tree.                   #
############################## Parse Arguments ##############################

# Set default values
process=""
schedule="always"

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --task)
            task="$2"           # evaluate or release
            shift 2
            ;;
        --process)
            process="$2"        # name of subprocess
            shift 2
            ;;
        --type)
            type="$2"           # execution, lock or pulldate
            shift 2
            ;;
        --schedule)
            schedule="$2"       # Schedule for execution
            shift 2
            ;;
        *)
            $NOTIFIER --channel "system" --args "warning" --message "ERROR: $JOB_NAME ConditionHandler unknown option: $1"
            exit 1
            ;;
    esac
done

# Check for necessary arguments. 
if [[ -z "$task" || -z "$type" ]]; then
    $NOTIFIER --channel "system" --args "warning" --message "ERROR: $JOB_NAME ConditionHandler --task and --type are required"
    exit 1
fi

################################# Variables #################################

timestamp=$(date +%Y%m%d)
dir_path="$HOME_PATH/ConditionMarks"
mkdir -p $dir_path
if [ -z "$process" ]; then
    marker_file="$dir_path/${JOB_NAME}_${timestamp}.$type"
else
    marker_file="$dir_path/${JOB_NAME}_${process}_${timestamp}.$type"
fi

################################# Funktions #################################

cleanup_locks() {
    # Iterate through files that match the pattern filename_*.lock
    for file in "$dir_path"/*.$type; do
        # Extract the filename without the path
        local file_name=$(basename "$file")

        # Extract the date from the filename (assuming the format filename_YYYYMMDD.lock)
        if [[ "$file_name" =~ [0-9]{8} ]]; then
            file_date=${BASH_REMATCH[0]}

            # Compare the extracted date with today's date
            if [ "$file_date" != "$timestamp" ]; then
                # Delete the file if the date does not match today's date
                rm "$file"
            fi
        fi
    done
}

decode_schedule() {
# Usage: check_date <pattern>
#  - <pattern> can be one of the following:
#     - "always": Execute the function every time it is called.
#     - "weekly: Mon, Tue, Wed, Thu, Fri, Sat, Sun": Execute the function on the specified days of the week.
#       Replace the example days with your desired days.
#     - "monthly: <day>": Execute the function on the specified day of the month.
#       Replace <day> with the desired day of the month (e.g., "1" for the 1st day, "15" for the 15th day).
#     - "never": Never execute the function.
    local sched=$1
    local current_date=$(date +%F)                              # Get current date in YYYY-MM-DD format

    if [[ "$sched" == "always" ]]; then
        return 0                                                # Match found, return true

    elif [[ "$sched" == weekly* ]]; then
        local days="${sched#weekly: }"                       # Extract the days of the week
        local current_day_of_week=$(date +%a)                   # Get current day of the week (e.g., Mon, Tue)

        if [[ "$days" == *"$current_day_of_week"* ]]; then
            return 0                                            # Match found, return true
        fi

    elif [[ "$sched" == monthly* ]]; then
        local day_of_month="${sched#monthly: }"              # Extract the day of the month
        local current_day_of_month=$(date +%d)                  # Get current day of the month

        echo $current_day_of_month

        if [[ "$current_day_of_month" -eq "$day_of_month" ]]; then
            echo "Match found"
            return 0                                            # Match found, return true
        fi

    elif [[ "$sched" == "never" ]]; then
        return 99                                               # Match found, return "no execution code 99"
    fi

    return 1                                                    # No match found, return false
}

################################## Jobs #####################################

if [ "$task" == "evaluate" ] && [ "$type" == "execution" ]; then
    
    if [[ -f "$marker_file" ]]; then          # Check if lock file exists
        $NOTIFIER --channel "file"
        $NOTIFIER --channel "system" --args "normal" --message "$JOB_NAME: Mark for 'execution' is already set"
        exit 99
        
    else                                    # Create lock file if none exists
        touch "$marker_file"
        $NOTIFIER --channel "file"
        $NOTIFIER --channel "file" --message "Create '$(basename "$marker_file")'"
        exit 0
    fi


elif [ "$task" == "release" ] && [ "$type" == "execution" ]; then

    rm $marker_file
    $NOTIFIER --channel "file"
    $NOTIFIER --channel "file" --message "Delete Mark '$(basename "$marker_file")'"
    exit 0


elif [ "$task" == "evaluate" ] && [ "$type" == "lock" ]; then

    cleanup_locks

    if [[ -f "$marker_file" && $schedule != "always" ]]; then
        $NOTIFIER --channel "file"
        $NOTIFIER --channel "file" --message "Mark for '$(basename "$marker_file")' is already set"
        exit 99
    fi

    decode_schedule "$schedule"
    result=$?
    if [ $result -eq 0 ] ; then
        touch "$marker_file"
        $NOTIFIER --channel "file"
        $NOTIFIER --channel "file" --message "Create '$(basename "$marker_file")'"
        exit 0

    elif [ $result -eq 99 ]; then
        $NOTIFIER --channel "file"
        $NOTIFIER --channel "file" --message "Skipped '$process' due to the schedule '$schedule'"
        exit 99
    else
        $NOTIFIER --channel "system" --args "warning" --message "ERROR: $process schedule '$schedule' is no valid option"
        $NOTIFIER --channel "file" --message "Here are some examples of valid options:"
        $NOTIFIER --channel "file" --message "'always'"
        $NOTIFIER --channel "file" --message "'weekly: Mon, Tue, Thu, Sat'"
        $NOTIFIER --channel "file" --message "'monthly: 12'"
        $NOTIFIER --channel "file" --message "'never'"
        exit 1
    fi
    
else
    $NOTIFIER --channel "system" --args "warning" --message "ERROR: $JOB_NAME ConditionHandler command unknown"
    exit 1
fi
